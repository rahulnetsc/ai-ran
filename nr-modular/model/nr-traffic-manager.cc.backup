/*
 * Copyright (c) 2026 ARTPARK
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * FIXED VERSION - Separate DL/UL application containers
 */

#include "nr-traffic-manager.h"
#include "utils/nr-sim-config.h"
#include "nr-network-manager.h"

#include "ns3/log.h"
#include "ns3/abort.h"
#include "ns3/internet-stack-helper.h"
#include "ns3/ipv4-address-helper.h"
#include "ns3/point-to-point-helper.h"

#include "ns3/nr-point-to-point-epc-helper.h"
#include "ns3/on-off-helper.h"
#include "ns3/packet-sink-helper.h"
#include "ns3/ipv4-static-routing-helper.h"
#include "ns3/ipv4.h"

#include <iostream>

namespace ns3
{

NS_LOG_COMPONENT_DEFINE("NrTrafficManager");
NS_OBJECT_ENSURE_REGISTERED(NrTrafficManager);

TypeId
NrTrafficManager::GetTypeId()
{
    static TypeId tid = TypeId("ns3::NrTrafficManager")
                            .SetParent<Object>()
                            .SetGroupName("NrModular")
                            .AddConstructor<NrTrafficManager>();
    return tid;
}

     
#include <map>

// Global map to track print counts for each debug context
static std::map<std::string, uint32_t> g_traceCounters;
const uint32_t MAX_DEBUG_PRINTS = 10; // Adjust this number as needed

// For PacketSink Rx (Application Layer)
static void
AppRxTracer (std::string context, Ptr<const Packet> packet, const Address &address)
{
    if (g_traceCounters[context] < MAX_DEBUG_PRINTS)
    {
        std::cout << "  [APP TRACE] Received at " << context << " from " << address 
                  << " size: " << packet->GetSize() << " (#" << ++g_traceCounters[context] << ")" << std::endl;
        
        if (g_traceCounters[context] == MAX_DEBUG_PRINTS)
            std::cout << "  [APP TRACE] " << context << " - Max prints reached. Silencing..." << std::endl;
    }
}

// For Ipv4 Protocol (Network Layer Tx/Rx)
static void
Ipv4Tracer (std::string context, Ptr<const Packet> packet, Ptr<Ipv4> ipv4, uint32_t interface)
{
    if (g_traceCounters[context] < MAX_DEBUG_PRINTS)
    {
        std::cout << "  [L3 TRACE] " << context << " on interface " << interface 
                  << " size: " << packet->GetSize() << " (#" << ++g_traceCounters[context] << ")" << std::endl;

        if (g_traceCounters[context] == MAX_DEBUG_PRINTS)
            std::cout << "  [L3 TRACE] " << context << " - Max prints reached. Silencing..." << std::endl;
    }
}

// For Ipv4 Drops
static void
Ipv4DropTracer (std::string context, const Ipv4Header &header, Ptr<const Packet> packet, 
                Ipv4L3Protocol::DropReason reason, Ptr<Ipv4> ipv4, uint32_t interface)
{
    // We usually want to see more drops, so maybe higher limit or no limit
    if (g_traceCounters[context] < MAX_DEBUG_PRINTS)
    {
        std::cout << "  [!!! DROP !!!] at " << context << " Reason: " << reason 
                  << " Dest: " << header.GetDestination() << " (#" << ++g_traceCounters[context] << ")" << std::endl;
    }
}


NrTrafficManager::NrTrafficManager()
    : m_config(nullptr),
      m_networkManager(nullptr),
      m_installed(false)
{
}

NrTrafficManager::~NrTrafficManager()
{
}

void
NrTrafficManager::DoDispose()
{
    m_config = nullptr;
    m_networkManager = nullptr;
    
    // Clear all application containers
    m_dlServerApps = ApplicationContainer();
    m_dlClientApps = ApplicationContainer();
    m_ulServerApps = ApplicationContainer();
    m_ulClientApps = ApplicationContainer();
    
    // Legacy containers for backward compatibility
    m_serverApps = ApplicationContainer();
    m_clientApps = ApplicationContainer();
    
    m_installed = false;
    Object::DoDispose();
}

void
NrTrafficManager::SetNetworkManager(Ptr<NrNetworkManager> netMgr)
{
    NS_LOG_FUNCTION(this);
    NS_ABORT_MSG_IF(netMgr == nullptr, "NetworkManager cannot be null");
    m_networkManager = netMgr;
}

void
NrTrafficManager::SetConfig(const Ptr<NrSimConfig>& config)
{
    NS_ABORT_MSG_IF(config == nullptr, "NrTrafficManager: config cannot be null");
    m_config = config;
}

void
NrTrafficManager::InstallTraffic(const NodeContainer& gnbNodes,
                                 const NodeContainer& ueNodes)
{
    NS_ABORT_MSG_IF(m_config == nullptr, "Config must be set before installing traffic");
    NS_ABORT_MSG_IF(m_networkManager == nullptr, "NetworkManager must be set before installing traffic");  
    NS_ABORT_MSG_IF(m_installed, "Traffic already installed");

    std::cout << "\n========================================" << std::endl;
    std::cout << "Installing UDP traffic applications" << std::endl;
    std::cout << "========================================" << std::endl;
    std::cout << "gNBs: " << gnbNodes.GetN() << std::endl;
    std::cout << "UEs: " << ueNodes.GetN() << std::endl;

    std::string dlRate = std::to_string(m_config->traffic.udpRateDl) + "Mbps";
    std::string ulRate = std::to_string(m_config->traffic.udpRateUl) + "Mbps";
    uint32_t dlPacketSize = m_config->traffic.packetSizeDl;
    uint32_t ulPacketSize = m_config->traffic.packetSizeUl;
    
    std::cout << "Traffic config:" << std::endl;
    std::cout << "  DL: " << dlRate << " (" << dlPacketSize << " bytes)" << std::endl;
    std::cout << "  UL: " << ulRate << " (" << ulPacketSize << " bytes)" << std::endl;

    // =================================================================
    // STEP 1: Get UE IP addresses from network manager
    // =================================================================
    Ipv4InterfaceContainer ueIpIfaces = m_networkManager->GetUeIpInterfaces();
    
    std::cout << "\nUE IP addresses:" << std::endl;
    for (uint32_t i = 0; i < std::min(3u, (uint32_t)ueIpIfaces.GetN()); ++i)
    {
        std::cout << "  UE " << i << ": " << ueIpIfaces.GetAddress(i, 0) << std::endl;
    }
    if (ueIpIfaces.GetN() > 3)
    {
        std::cout << "  ... (" << (ueIpIfaces.GetN() - 3) << " more)" << std::endl;
    }

    // =================================================================
    // STEP 2: Create Remote Host (based on cttc-3gpp-channel-nums.cc)
    // =================================================================
    std::cout << "\nCreating remote host..." << std::endl;
    
    Ptr<Node> pgw = m_networkManager->GetEpcHelper()->GetPgwNode();
    Ptr<Node> remoteHost = CreateObject<Node>();
    
    // Install internet stack on remote host
    InternetStackHelper internet;
    internet.Install(remoteHost);
    
    std::cout << "  ✓ Remote host created (Node ID: " << remoteHost->GetId() << ")" << std::endl;

    // =================================================================
    // STEP 3: Create P2P link between remote host and PGW
    // =================================================================
    std::cout << "Connecting remote host to PGW..." << std::endl;
    
    PointToPointHelper p2ph;
    p2ph.SetDeviceAttribute("DataRate", DataRateValue(DataRate("100Gb/s")));
    p2ph.SetDeviceAttribute("Mtu", UintegerValue(1500));
    p2ph.SetChannelAttribute("Delay", TimeValue(MilliSeconds(0)));
    
    NodeContainer internetNodes;
    internetNodes.Add(pgw);
    internetNodes.Add(remoteHost);
    NetDeviceContainer internetDevices = p2ph.Install(internetNodes);
    
    std::cout << "  ✓ P2P link created" << std::endl;

    // =================================================================
    // STEP 4: Assign IP addresses to P2P link
    // =================================================================
    std::cout << "Assigning IP addresses to P2P link..." << std::endl;
    
    Ipv4AddressHelper ipv4h;
    ipv4h.SetBase("1.0.0.0", "255.0.0.0");
    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);
    
    Ipv4Address remoteHostAddr = internetIpIfaces.GetAddress(1);
    
    std::cout << "  PGW (SGi): " << internetIpIfaces.GetAddress(0) << std::endl;
    std::cout << "  Remote host: " << remoteHostAddr << std::endl;

    // =================================================================
    // STEP 5: Setup routing
    // =================================================================
    std::cout << "Configuring routing..." << std::endl;
    
    Ipv4StaticRoutingHelper ipv4RoutingHelper;
    Ptr<Ipv4StaticRouting> remoteHostStaticRouting = 
        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());
    
    // Get the PGW IP on the P2P link (Interface 0 of the link is PGW)
    Ipv4Address pgwAddr = internetIpIfaces.GetAddress(0); 

    // Add route: Network, Mask, NextHop, InterfaceIndex
    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address("7.0.0.0"), Ipv4Mask("255.0.0.0"), pgwAddr, 1);
    
    std::cout << "  ✓ Route added: 7.0.0.0/8 via PGW" << std::endl;

    // Debug: Print routing table
    std::cout << "\n  --- Remote Host Routing Table ---" << std::endl;
    Ptr<OutputStreamWrapper> routingStream = Create<OutputStreamWrapper>(&std::cout);
    remoteHostStaticRouting->PrintRoutingTable(routingStream);

    // Debug: Print PGW routing table
    Ptr<Ipv4> pgwIpv4 = pgw->GetObject<Ipv4>();
    Ptr<Ipv4StaticRouting> pgwStaticRouting = ipv4RoutingHelper.GetStaticRouting(pgwIpv4);
    std::cout << "\n  --- PGW Routing Table ---" << std::endl;
    pgwStaticRouting->PrintRoutingTable(routingStream);

    // =================================================================
    // STEP 6: Install traffic applications (FIXED - SEPARATE CONTAINERS)
    // =================================================================
    std::cout << "\nInstalling traffic applications..." << std::endl;
    
    uint16_t dlPort = 10000;
    uint16_t ulPort = 20000;
    double startTime = 2.0;
    double stopTime = m_config->simDuration;

    // =================================================================
    // PHASE 1: Install ALL DOWNLINK applications first
    // =================================================================
    std::cout << "  Phase 1: Installing downlink flows..." << std::endl;
    for (uint32_t i = 0; i < ueNodes.GetN(); ++i)
    {
        Ipv4Address ueAddr = ueIpIfaces.GetAddress(i, 0);

        // DL Sink: on UE, listening on dlPort + i
        PacketSinkHelper dlSink("ns3::UdpSocketFactory",
                               InetSocketAddress(Ipv4Address::GetAny(), dlPort + i));
        m_dlServerApps.Add(dlSink.Install(ueNodes.Get(i)));
        
        // DL Source: on remote host, sending to UE
        OnOffHelper dlClient("ns3::UdpSocketFactory",
                            InetSocketAddress(ueAddr, dlPort + i));
        dlClient.SetAttribute("PacketSize", UintegerValue(dlPacketSize));
        dlClient.SetConstantRate(DataRate(dlRate));
        m_dlClientApps.Add(dlClient.Install(remoteHost));
    }
    std::cout << "    ✓ " << ueNodes.GetN() << " DL flows (Remote → UEs)" << std::endl;

    // =================================================================
    // PHASE 2: Install ALL UPLINK applications
    // =================================================================
    std::cout << "  Phase 2: Installing uplink flows..." << std::endl;
    for (uint32_t i = 0; i < ueNodes.GetN(); ++i)
    {
        // UL Sink: on remote host, listening on ulPort + i
        PacketSinkHelper ulSink("ns3::UdpSocketFactory",
                               InetSocketAddress(Ipv4Address::GetAny(), ulPort + i));
        m_ulServerApps.Add(ulSink.Install(remoteHost));
        
        // UL Source: on UE, sending to remote host
        OnOffHelper ulClient("ns3::UdpSocketFactory",
                            InetSocketAddress(remoteHostAddr, ulPort + i));
        ulClient.SetAttribute("PacketSize", UintegerValue(ulPacketSize));
        ulClient.SetConstantRate(DataRate(ulRate));
        m_ulClientApps.Add(ulClient.Install(ueNodes.Get(i)));
    }
    std::cout << "    ✓ " << ueNodes.GetN() << " UL flows (UEs → Remote)" << std::endl;

    // =================================================================
    // Build combined containers for backward compatibility
    // =================================================================
    std::cout << "  Building combined containers..." << std::endl;
    
    // m_serverApps = all DL sinks + all UL sinks
    for (uint32_t i = 0; i < m_dlServerApps.GetN(); ++i)
    {
        m_serverApps.Add(m_dlServerApps.Get(i));
    }
    for (uint32_t i = 0; i < m_ulServerApps.GetN(); ++i)
    {
        m_serverApps.Add(m_ulServerApps.Get(i));
    }
    
    // m_clientApps = all DL sources + all UL sources
    for (uint32_t i = 0; i < m_dlClientApps.GetN(); ++i)
    {
        m_clientApps.Add(m_dlClientApps.Get(i));
    }
    for (uint32_t i = 0; i < m_ulClientApps.GetN(); ++i)
    {
        m_clientApps.Add(m_ulClientApps.Get(i));
    }

    std::cout << "    ✓ Combined containers created" << std::endl;
    std::cout << "      - m_serverApps: " << m_serverApps.GetN() << " apps" << std::endl;
    std::cout << "      - m_clientApps: " << m_clientApps.GetN() << " apps" << std::endl;

    // =================================================================
    // STEP 7: Setup tracing
    // =================================================================
    std::cout << "\nSetting up tracing..." << std::endl;
    
    // Trace DL sinks (on UEs)
    for (uint32_t i = 0; i < m_dlServerApps.GetN(); ++i)
    {
        std::string context = "DL_Sink_UE_" + std::to_string(i);
        m_dlServerApps.Get(i)->TraceConnectWithoutContext("Rx", MakeCallback(&AppRxTracer).Bind(context));
    }
    
    // Trace UL sinks (on remote host)
    for (uint32_t i = 0; i < m_ulServerApps.GetN(); ++i)
    {
        std::string context = "UL_Sink_Remote_" + std::to_string(i);
        m_ulServerApps.Get(i)->TraceConnectWithoutContext("Rx", MakeCallback(&AppRxTracer).Bind(context));
    }

    // Hook the Remote Host Network Layer (L3)
    Ptr<Ipv4L3Protocol> remoteHostIpv4 = remoteHost->GetObject<Ipv4L3Protocol>();
    remoteHostIpv4->TraceConnectWithoutContext("Tx", MakeCallback(&Ipv4Tracer).Bind("RemoteHost_L3_TX"));
    remoteHostIpv4->TraceConnectWithoutContext("Rx", MakeCallback(&Ipv4Tracer).Bind("RemoteHost_L3_RX"));

    // Hook the UE Network Layer (L3)
    for (uint32_t i = 0; i < ueNodes.GetN(); ++i)
    {
        Ptr<Ipv4L3Protocol> ueIpv4 = ueNodes.Get(i)->GetObject<Ipv4L3Protocol>();
        std::string txCtx = "UE_L3_TX_" + std::to_string(i);
        std::string rxCtx = "UE_L3_RX_" + std::to_string(i);
        std::string dropCtx = "UE_L3_DROP_" + std::to_string(i);
        
        ueIpv4->TraceConnectWithoutContext("Tx", MakeCallback(&Ipv4Tracer).Bind(txCtx));
        ueIpv4->TraceConnectWithoutContext("Rx", MakeCallback(&Ipv4Tracer).Bind(rxCtx));
        ueIpv4->TraceConnectWithoutContext("Drop", MakeCallback(&Ipv4DropTracer).Bind(dropCtx));
    }

    std::cout << "  ✓ Tracing configured" << std::endl;

    // =================================================================    
    // Start/stop applications
    // =================================================================
    std::cout << "\nScheduling application start/stop times..." << std::endl;
    
    // Give the 5G stack time to attach and setup routes
    double transportStart = startTime + 1.0; 

    // Start all sinks first (both DL and UL)
    m_dlServerApps.Start(Seconds(transportStart));
    m_ulServerApps.Start(Seconds(transportStart));
    
    // Start sources slightly later
    m_dlClientApps.Start(Seconds(transportStart + 0.1));
    m_ulClientApps.Start(Seconds(transportStart + 0.1));
    
    // Stop all applications at simulation end
    m_dlServerApps.Stop(Seconds(stopTime));
    m_ulServerApps.Stop(Seconds(stopTime));
    m_dlClientApps.Stop(Seconds(stopTime));
    m_ulClientApps.Stop(Seconds(stopTime));

    std::cout << "  ✓ Start time: " << transportStart << " s" << std::endl;
    std::cout << "  ✓ Stop time: " << stopTime << " s" << std::endl;

    m_installed = true;

    std::cout << "\n========================================" << std::endl;
    std::cout << "Traffic installation complete!" << std::endl;
    std::cout << "  DL: " << m_dlServerApps.GetN() << " sinks + " << m_dlClientApps.GetN() << " sources" << std::endl;
    std::cout << "  UL: " << m_ulServerApps.GetN() << " sinks + " << m_ulClientApps.GetN() << " sources" << std::endl;
    std::cout << "  Total applications: " << (m_serverApps.GetN() + m_clientApps.GetN()) << std::endl;
    std::cout << "========================================\n" << std::endl;
}

// =================================================================
// Getters - Legacy (backward compatible)
// =================================================================
ApplicationContainer
NrTrafficManager::GetServerApps() const
{
    return m_serverApps;
}

ApplicationContainer
NrTrafficManager::GetClientApps() const
{
    return m_clientApps;
}

// =================================================================
// Getters - New separate containers
// =================================================================
ApplicationContainer
NrTrafficManager::GetDlServerApps() const
{
    return m_dlServerApps;
}

ApplicationContainer
NrTrafficManager::GetDlClientApps() const
{
    return m_dlClientApps;
}

ApplicationContainer
NrTrafficManager::GetUlServerApps() const
{
    return m_ulServerApps;
}

ApplicationContainer
NrTrafficManager::GetUlClientApps() const
{
    return m_ulClientApps;
}

bool
NrTrafficManager::IsInstalled() const
{
    return m_installed;
}

} // namespace ns3